# Network Systems, Programming Assignment 1

# Christopher Bate

# September, 2018

## Introduction

This C++ program implements a stateful reliable transfer protocol over UDP. The overall
mechanism is modeled after TCP, with some simplifications as explained below. A persistent, full-duplex sliding window transfer mechanism with automatic rate control to handle buffer overruns is achieved. It has a flexible advertised window mechanism and re-transmission scheme. All requirements in the specification are met, including reliable transfer
and non-blocking operation (all packet sending/receiving is handled in seperate threads, reading from receive buffer will not block if there is no data, but writing to the send buffer will block if the send buffer is full).

I call the "simplified TCP" protocol that I implement the "CTB" protocol. ("CTB" are
my initials.)

Please ignore the files_server and files_client directories. Those are for automated unit tests run by the bin/tests executable.

PLEASE NOTE: When request a GET or PUT, the program will print "Received: [filename] [size]". This is just the header. For large files, there will always be statements like "x/total bytes received" and "Transfer complete, took x milliseconds" to signal end of transfer.

## Building the Source

Both a Makefile and Dockerfile are provided for compilation. Simply run "make" in the
program directory. Executables will be generated in the "server_bin" and "client_bin" directories. Test files are already in the "client_bin" directory.

I tested compilation on CSEL machine, and everything was normal. However, I've provided a dockefile that 100% for certain builds in docker on any machine if there is any doubt. 
For Docker build, run "docker build ." and then "docker run (container id generated by build)".
The docker run will build the app and run the server. To copy the server and client executables, just run "docker cp [container id]:/out/client /output/directory" and a and "docker cp [container id]:/out/server /output/directory" to get them on your local machine.

## Source Code Organization

All source code C++ files are in the "src" directory, while headers are in the
"inc" directory. The client and server have seperate files for main entry-points,
and they are labeled appropriately. However, Client and Server have significant
code overlap in that they use the same classes as an API into the CTB protocol,
as explained below.

## Architecture

There are several classes in this program.

-   SocketDevice: A simple wrapper around basic UDP operations over sockets
-   CTBDevice: Implements the "CTB Protocol".
-   RecvBuffer: Implements sliding window aspects for the receiving buffer, used by CTBDevice
-   SendBuffer: Similar to the above, but for the sending buffer

The CTBDevice class uses the SocketDevice, RecvBuffer, and SendBuffer classes to implement the CTB protocol.

Non-blocking operation is achieved using threads. Both the client and server have two threads. One thread
runs the CTBProtocol, send and receiving data into the buffers, while the other thread reads and writes data
into the buffers.

## The CTB Protocol

The CTBDevice implements the CTB protocol. Here, I give a basic overview
of the API with an explanation of how each functions works.

-   ActiveConnect: Performs an an "active" connection to the server using 3-way handshake (as described in book)
-   Listen: Listens for connection and performs three way handshake (as descrbed in book)
-   SendData: Writes data given by the user into the SendBuffer
-   RecvData: Takes data (if available) and copies it into a buffer provided by the user
-   Update: If data is in the SendBuffer and the server/client's advertised window is open, this function will send data to the other host. The data that is sent is dictated by sliding window. Which sequence number is next in the queue and which was last acknowledged is handled by the SendBuffer class. Then, it checks for UDP packets, and if they are available, it sends them to RecvBuffer, which handles assembly and local sliding window information.


## File Transfer Protocol

There is another layer built on top of the CTB Protocol (nuch like HTTP on top of TCP). The details for this protocol is given in the "Request.h/cpp" and "Response.h/cpp" files. The client always initiates with a request (including header and body) and the server sends a response. Each operation has a protocol as given blow:

#### GET
- Client Sends: Header: get [filename] Body: None
- Server Responds:[filename] [size] Body: Data of size [size]
  Client saves response to file. If no filename is found, server responds with "none 0".

#### PUT
- Client Sends: Header: put [filename] [size] Body: Data of size [size]
- Server Responds: Header: ok (if save successful) fail (if sae not successful) Body: None

#### LS
- Client Sends: Header: ls Body: none
- Server Responds: Header: ok [size] Body: string of size [size]
If the server fails to execute the ls command and get the data, it responds with "none 0".

#### DELETE
- Client Sends: Header: delete [filename] Body: None
- Server Responds: Header: ok (if success) fail (if not success) Body: None